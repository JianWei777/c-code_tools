!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ACK	pcap_analyse.h	/^			 ACK:1,		\/\/\/< 确认序号有效$/;"	m	struct:_comm_tcp_head
CC	Makefile	/^CC = gcc$/;"	m
Caplen	pcap_analyse.h	/^	uint32_t Caplen;		\/\/\/< 到下一帧的偏移$/;"	m	struct:_frame_head
DFLAGS	Makefile	/^DFLAGS = fpic -shared$/;"	m
FIN	pcap_analyse.h	/^			 FIN:1;		\/\/\/< 发端完成发送任务$/;"	m	struct:_comm_tcp_head
LIBS	Makefile	/^LIBS = -L..\/libs -lpcap$/;"	m
Len	pcap_analyse.h	/^	uint32_t Len;			\/\/\/< 实际上下一帧的偏移，绝大多数情况下等于caplen，可能会小于caplen$/;"	m	struct:_frame_head
OBJ	Makefile	/^OBJ = $(patsubst %.c,%.o,$(SRC))$/;"	m
PCAP_ERRBUF_SIZE	manger.c	19;"	d	file:
PCAP_FILE_PATH	manger.c	18;"	d	file:
PLATFORM	Makefile	/^PLATFORM = ..\/..\/$/;"	m
PSH	pcap_analyse.h	/^			 PSH:1,		\/\/\/< 接收方应该尽快将这个报文段交给应用层$/;"	m	struct:_comm_tcp_head
RST	pcap_analyse.h	/^			 RST:1,		\/\/\/< 重建连接$/;"	m	struct:_comm_tcp_head
SFLAGS	Makefile	/^SFLAGS = -c$/;"	m
SRC	Makefile	/^SRC = $(wildcard *.c) $(wildcard *.cpp)$/;"	m
SYN	pcap_analyse.h	/^			 SYN:1,		\/\/\/< 同步序号用来发起一个连接$/;"	m	struct:_comm_tcp_head
TARGET	Makefile	/^TARGET = ..\/bin\/pcap_filter$/;"	m
TOS	pcap_analyse.h	/^	uint8_t TOS;		\/\/\/< type of service$/;"	m	struct:_comm_ip_head
Timestamp_sec	pcap_analyse.h	/^	uint32_t Timestamp_sec;	 \/\/\/< 时间戳高位，精度 秒$/;"	m	struct:_frame_head
Timestamp_usec	pcap_analyse.h	/^	uint32_t Timestamp_usec; \/\/\/< 时间戳低位，精度 微秒$/;"	m	struct:_frame_head
UGR	pcap_analyse.h	/^			 UGR:1,		\/\/\/< 紧急指针 $/;"	m	struct:_comm_tcp_head
_comm_eth_head	pcap_analyse.h	/^typedef struct _comm_eth_head{$/;"	s
_comm_ip_head	pcap_analyse.h	/^typedef struct _comm_ip_head{$/;"	s
_comm_tcp_head	pcap_analyse.h	/^typedef struct _comm_tcp_head{$/;"	s
_comm_udp_head	pcap_analyse.h	/^typedef struct _comm_udp_head{$/;"	s
_frame_head	pcap_analyse.h	/^typedef struct _frame_head{$/;"	s
_pcap_file_head	pcap_analyse.h	/^typedef struct _pcap_file_head{$/;"	s
ack	pcap_analyse.h	/^	uint32_t ack;			\/\/\/< 确认序号应当是上次已成功收到数据字节序号加 1$/;"	m	struct:_comm_tcp_head
check_sum	pcap_analyse.h	/^	uint16_t  check_sum;\/\/\/< udp校验和$/;"	m	struct:_comm_udp_head
checksum	pcap_analyse.h	/^	uint16_t checksum;		\/\/\/< 检验和覆盖了整个的 T C P报文段：T C P首部和T C P数据$/;"	m	struct:_comm_tcp_head
checksum	pcap_analyse.h	/^	uint16_t checksum;$/;"	m	struct:_comm_ip_head
comm_eth_head_t	pcap_analyse.h	/^}comm_eth_head_t;$/;"	t	typeref:struct:_comm_eth_head
comm_init	manger.c	/^int comm_init()$/;"	f
comm_ip_head_t	pcap_analyse.h	/^}comm_ip_head_t;$/;"	t	typeref:struct:_comm_ip_head
comm_tcp_head_t	pcap_analyse.h	/^}comm_tcp_head_t;$/;"	t	typeref:struct:_comm_tcp_head
comm_udp_head_t	pcap_analyse.h	/^}comm_udp_head_t;$/;"	t	typeref:struct:_comm_udp_head
deal_with_cmdline	manger.c	/^static int deal_with_cmdline(int argc ,char** argv)$/;"	f	file:
dport	pcap_analyse.h	/^	uint16_t  dport;$/;"	m	struct:_comm_udp_head
dport	pcap_analyse.h	/^	uint16_t dport;			\/\/\/< 目的端口$/;"	m	struct:_comm_tcp_head
dst_ip	pcap_analyse.h	/^	uint32_t dst_ip;$/;"	m	struct:_comm_ip_head
dst_mac	pcap_analyse.h	/^	uint8_t dst_mac[6];		\/\/\/< 目标mac地址$/;"	m	struct:_comm_eth_head
falg	pcap_analyse.h	/^	uint16_t falg:3,	\/\/\/< 3位标志$/;"	m	struct:_comm_ip_head
flag	pcap_analyse.h	/^	uint16_t flag;		\/\/\/< 16位标识$/;"	m	struct:_comm_ip_head
frame_head_t	pcap_analyse.h	/^}frame_head_t;$/;"	t	typeref:struct:_frame_head
g_ip_datasize	manger.c	/^static uint64_t g_ip_datasize;	\/\/\/< 用于进行ip数据统计计数$/;"	v	file:
g_pcap_handle	manger.c	/^static pcap_t *g_pcap_handle;$/;"	v	file:
g_pkt_num	manger.c	/^static uint64_t g_pkt_num;		\/\/\/< 用于进行包计数$/;"	v	file:
g_print_flag	manger.c	/^static volatile uint8_t g_print_flag;	\/\/\/< 用于控制终端展示$/;"	v	file:
head_len	pcap_analyse.h	/^	uint16_t head_len:4,	\/\/\/< 首部长度$/;"	m	struct:_comm_tcp_head
headlen	pcap_analyse.h	/^			headlen:4;	\/\/\/< 头部实际长度$/;"	m	struct:_comm_ip_head
headlen	pcap_analyse.h	/^	uint16_t  headlen;	\/\/\/< UDP首部和UDP数据的字节长度$/;"	m	struct:_comm_udp_head
iplen	pcap_analyse.h	/^	uint16_t iplen;		\/\/\/< ip数据报总长度$/;"	m	struct:_comm_ip_head
linktype	pcap_analyse.h	/^	uint32_t  linktype;   \/\/\/< 链路类型。解析数据包首先要判断它的LinkType，所以这个值很重要。一般的值为1，即以太网$/;"	m	struct:_pcap_file_head
magic	pcap_analyse.h	/^	uint32_t  magic;		\/\/\/< pcap文件的幻数$/;"	m	struct:_pcap_file_head
main	manger.c	/^int main(int argc ,char **argv)$/;"	f
offset	pcap_analyse.h	/^			 offset:13;\/\/\/< 13位片偏移$/;"	m	struct:_comm_ip_head
pcap_callback	manger.c	/^static void pcap_callback(u_char* argument, const struct pcap_pkthdr* packet_header, const u_char* packet_content)$/;"	f	file:
pcap_file_t	pcap_analyse.h	/^}pcap_file_t;$/;"	t	typeref:struct:_pcap_file_head
protocol	pcap_analyse.h	/^	uint8_t  protocol;$/;"	m	struct:_comm_ip_head
reserved	pcap_analyse.h	/^			 reserved:6,	\/\/\/< 保留位$/;"	m	struct:_comm_tcp_head
seq	pcap_analyse.h	/^	uint32_t seq;			\/\/\/< 序号字段$/;"	m	struct:_comm_tcp_head
show_usage	manger.c	/^static void show_usage()$/;"	f	file:
sigfigs	pcap_analyse.h	/^	uint32_t  sigfigs;    \/\/\/< 时间戳的精度，一般为全零$/;"	m	struct:_pcap_file_head
snaplen	pcap_analyse.h	/^	uint32_t  snaplen;    \/\/\/< 最大的存储长度，设置所抓获的数据包的最大长度，如果所有数据包都要抓获，将值设置为65535$/;"	m	struct:_pcap_file_head
sport	pcap_analyse.h	/^	uint16_t  sport;$/;"	m	struct:_comm_udp_head
sport	pcap_analyse.h	/^	uint16_t sport;			\/\/\/< 源端口$/;"	m	struct:_comm_tcp_head
src_ip	pcap_analyse.h	/^	uint32_t src_ip;$/;"	m	struct:_comm_ip_head
src_mac	pcap_analyse.h	/^	uint8_t src_mac[6];		\/\/\/< 源mac地址$/;"	m	struct:_comm_eth_head
target_pcap_file	manger.c	/^static uint8_t target_pcap_file[PCAP_FILE_PATH];$/;"	v	file:
thiszone	pcap_analyse.h	/^	uint32_t  thiszone;		\/\/\/< 当地的标准时间，如果用的是GMT则全零，一般全零$/;"	m	struct:_pcap_file_head
ttl	pcap_analyse.h	/^	uint8_t  ttl;	\/\/\/< time to live 生存时间$/;"	m	struct:_comm_ip_head
type	pcap_analyse.h	/^	uint16_t type;			\/\/\/<  请求类型  0x0800 ip数据 0x0806 arp 请求 0x8035 rarp 请求$/;"	m	struct:_comm_eth_head
urgent_ptr	pcap_analyse.h	/^	uint16_t urgent_ptr;	\/\/\/< T C P的紧急方式是发送端向另一端发送紧急数据的一种方式。$/;"	m	struct:_comm_tcp_head
version	pcap_analyse.h	/^	uint8_t version:4,	\/\/\/< 版本$/;"	m	struct:_comm_ip_head
version_major	pcap_analyse.h	/^	uint16_t  version_major;	\/\/\/< 当前文件的主要版本号，一般为0x0200$/;"	m	struct:_pcap_file_head
version_minor	pcap_analyse.h	/^	uint16_t  version_minor;	\/\/\/< 当前文件的次要版本号，一般为0x0400$/;"	m	struct:_pcap_file_head
win_size	pcap_analyse.h	/^	uint16_t win_size;		\/\/\/< 窗口大小，T C P的流量控制由连接的每一端通过声明的窗口大小来提供$/;"	m	struct:_comm_tcp_head
